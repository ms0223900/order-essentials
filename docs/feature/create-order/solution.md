## 技術解決方案設計

### 1. 資料庫層設計

**1.1 新增整合函數 `create_order_with_inventory_deduction`**
- 將訂單建立與庫存扣減整合在單一資料庫交易中
- 使用 PostgreSQL 的 `plpgsql` 函數確保原子性操作
- 參數：顧客資訊、商品項目清單
- 流程：
  1. 檢查所有商品庫存可用性
  2. 計算總金額
  3. 產生 UUID 訂單編號
  4. 建立訂單記錄
  5. 建立訂單項目
  6. 批量扣除庫存
  7. 返回成功結果或回滾交易

**1.2 資料庫交易保證**
- 使用 `BEGIN`/`COMMIT`/`ROLLBACK` 確保 ACID 特性
- 任何步驟失敗時，整個交易自動回滾
- 避免部分成功導致資料不一致的狀況

### 2. 領域層設計

**2.1 擴展 `OrderRepository` 介面**
- 新增 `createOrderWithInventoryDeduction` 方法
- 保持現有 `createOrder` 方法以向後相容
- 新方法回傳包含庫存扣減結果的詳細資訊

**2.2 更新 `CreateOrderResponse` 介面**
- 新增 `inventoryDeductionResults` 欄位
- 包含每個商品的扣減前後庫存狀態
- 提供詳細的錯誤追蹤資訊

### 3. 基礎設施層設計

**3.1 更新 `SupabaseOrderRepository` 實作**
- 實作新整合方法呼叫 `create_order_with_inventory_deduction` 函數
- 處理 Supabase RPC 呼叫和錯誤轉換
- 提供統一的錯誤處理機制

**3.2 錯誤處理策略**
- 區分不同錯誤類型：庫存不足、商品不存在、資料庫錯誤
- 提供用戶友善的錯誤訊息
- 記錄詳細的錯誤資訊以便除錯

### 4. 應用服務層設計

**4.1 建立 `OrderService` 應用服務**
- 封裝複雜的業務邏輯
- 負責協調 Repository 和其他服務
- 處理跨領域的業務規則

**4.2 整合購物車和訂單流程**
- 在結帳流程中整合庫存檢查
- 確保購買流程的原子性
- 提供統一的交易介面

### 5. 前端整合設計

**5.1 更新結帳流程**
- 在提交訂單前進行前端庫存檢查
- 顯示即時庫存狀態
- 處理訂單建立失敗的錯誤顯示

**5.2 錯誤處理和用戶回饋**
- 區分不同錯誤類型顯示對應訊息
- 提供重新嘗試機制
- 避免重複提交

### 6. 測試策略設計

**6.1 單元測試**
- 測試 Repository 的各個方法
- 模擬 Supabase 函數呼叫
- 驗證錯誤處理邏輯

**6.2 整合測試**
- 測試完整的訂單建立流程
- 驗證資料庫交易的原子性
- 測試庫存扣減和訂單建立的一致性

**6.3 端到端測試**
- 測試從前端到資料庫的完整流程
- 驗證錯誤場景的處理
- 確保用戶體驗的一致性

### 7. 效能與擴展性設計

**7.1 資料庫效能優化**
- 使用適當的索引（訂單編號、建立時間）
- 優化批量操作的效能
- 監控查詢效能和鎖定爭用

**7.2 快取策略**
- 考慮在前端快取庫存資訊
- 使用適當的快取失效策略
- 平衡即時性和效能

### 8. 安全性和可靠性設計

**8.1 資料驗證**
- 前端和後端雙重驗證輸入資料
- 防止 SQL 注入和 XSS 攻擊
- 驗證商品存在性和庫存狀態

**8.2 監控和日誌**
- 記錄所有訂單操作
- 監控庫存變化
- 設定警報機制處理異常狀況

**8.3 資料一致性**
- 使用資料庫約束確保資料完整性
- 實作補償機制處理失敗情況
- 定期檢查資料一致性

### 9. 部署和遷移設計

**9.1 資料庫遷移**
- 建立新的整合函數
- 保留現有函數以向後相容
- 提供遷移腳本和回滾計劃

**9.2 零停機部署**
- 使用藍綠部署或滾動更新
- 確保舊版本和新版本的相容性
- 提供降級機制

### 10. 未來擴展性設計

**10.1 支援多種付款方式**
- 預留付款方式擴展介面
- 支援非同步付款處理
- 考慮第三方付款整合

**10.2 訂單狀態管理**
- 設計狀態機管理複雜的訂單流程
- 支援訂單取消和退貨流程
- 提供狀態變更的審計追蹤

**10.3 通知系統整合**
- 支援訂單狀態變更通知
- 整合郵件和簡訊通知
- 提供可擴展的通知介面

這個解決方案確保了訂單建立與庫存扣減的原子性，提供了完整的錯誤處理和用戶回饋機制，並考慮了未來的擴展需求。